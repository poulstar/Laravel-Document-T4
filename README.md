# پیاده سازی دریافت زیر مجموعه های یک نظر و آموزش مبحث join

###### برای اینکه بخواهیم ساختار دریافت زیر مجموعه های یک comment را داشته باشیم، لازم نیست route بنویسیم، چون از apiResource استفاده می کنیم. حال وارد CommentController شده و تابع show را می نویسیم.
```bash
public function show(Comment $comment)
{
    $comments = Comment::where('parent_id', $comment->id)
        ->join('users', 'comments.user_id', '=', 'users.id')
        ->select('comments.*', 'users.name', 'users.email')
        ->get();
    return $this->successResponse([
        'comments' => $comments,
    ], 200);
}
```
###### بخش پارامتر تابع را عوض می کنیم و از مدل comment استفاده می کنیم تا موقع ارسال ID، بلافاصله محتوا comment را برای ما پیدا کند. از طریق comment پیدا شده، به دنبال زیر مجموعه های آن می گردیم. دقت کنید که این کار را می شود از طریق ORM انجام داد، اما نمی توانید داده های user را هم با آن بفرستید. دقت کنید، ما می خواهیم داده های یکی comment به همراه نام و email کاربری که آن را ثبت کرده، به سمت درخواست دهنده ارسال کنیم، تا نمایش دهد. به  همین منظور می توانیم از join استفاده کنیم. برای مطالعه بیشتر می توانید به  <a href="https://laravel.com/docs/10.x/queries#joins">Laravel Join</a> رجوع کنید.

###### حال وقتی comment مورد نظر را یافتیم، از مدل comment استفاده می کنیم و یک شرط where بر روی آن می گذاریم تا تمام comment هایی که parent_id آن با شناسه comment دریافتی ما یکی است را شناسایی کند، سپس با استفاده از تابع join، شروع به ترکیب می کنیم. 
###### پارامتر اول تابع join، پارامتری است که باید در آن نام جدولی که می خواهید به جست و جو شما اضافه شود را تعیین کنید، از همین رو ما نام جدول users را نوشتیم. 
###### پارامتر دوم جایگاه متغیری از جدول اول یعنی comments است که باید تعیین کنیم کدام ستون آن ملاک سنجش است، از همین رو ما در comments از user_id استفاده می کنیم. به همین منظور ما مقدار comments.user_id را نوشتیم. 
###### پارامتر سوم نیز جایگاه نوشتن عملگر است که چگونه مقایسه کند، مساوی، بزرگ تر، کوچک تر و ... . ما چون به دنبال برابر بودن هستیم، مقدار را برابر با = گذاشتیم.
###### پارامتر چهارم تابع جایگاه متغیری از ستون جدول users است که ما می خواهیم با id جدول users بسنجد، از همین رو مقدار users.id را می نویسیم.
###### تا اینجا ما عمل ترکیب دو جدول را انجام داده ایم، اما موردی که باید به آن دقت نمود، این است که آیا ما همه مواردی از هر دو جدول را می خواهیم یا خیر، قطعا جواب درست خیر است، چون در ابتدا گفتیم که ما می خواهیم برای کار خود تمام اطلاعات comment و از user فقط نام و email را ارسال کنیم، از همین رو از select استفاده می کنیم. به همین منظور select را به صورت زیر می نویسیم. 
###### در جایگاه اول پارامتر comments را می نویسیم و با یک * اشاره می کنیم که تمام موارد جدول را می خواهیم، در پارامتر دوم users.name که یعنی از جدول users بخش name را می خواهیم و در پارامتر سوم users.email می گذاریم که یعنی از جدول users مقدار email کاربر را هم می خواهیم. 
###### در انتها تمام مواردی که یافت شد را به صورت یک پاسخ موفق به سمت درخواست دهنده ارسال می کنیم. برای اینکه ظاهر را داشته باشیم تا بتوانیم درخواست بزنیم و از عملکرد کد های خود آگاه شویم، به فایل api.yaml می رویم. برای کار خود لازم است ابتدا یک path در بخش paths بنویسیم.
```bash
/api/comments/{comment}:
    get:
      tags:
        - Comment
      summery: show Comment
      description: show any Comment
      parameters:
        - name: comment
          in: path
          description: comment ID
          schema:
            type: integer
          required: true
      responses:
        "200":
          description: Successful operation
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/ApiResponse"
      security:
        - bearerAuth: []
```
###### آدرس path را مطابق الگو apiResource می نویسیم و مقدار comment را به صورت متغیر در می آوریم. در داخل path از روش get استفاده می کنیم، یا به عبارتی در این path اگر بخواهیم با روش get درخواست بزنیم به صورت زیر خواهد بود، tag آن را مشخص می کنیم و برای خلاصه و توضیحات در نظر می گیریم. پارامتر comment را تعریف می کنیم و نوع آن را معین کرده و پر کردن را اجبار می کنیم، پاسخ را نیز مانند گذشته می سازیم و برای مسیر خود ساختار security را فعال می کنیم.
###### حال همه چی برای درخواست زدن و گرفتن تمام فرزندان یا به عبارتی زیر مجموعه های یکی comment فراهم است.
